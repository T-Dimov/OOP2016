Задача 1. 
Да се реализира клас „редица от числа”, съхраняващ членовете на редица от числа (integers) в масив, разположен в динамично заделена памет. Да се реализират:
- канонично представяне
- добавяне на елемент в края на редицата
- премахване на елемент на редица (по дадена стойност, маха всички елементи с тази стойност);
- намиране на средната стойност на елементите в редицата;
- извеждане на редица; (operator<<)
- булев метод, който проверява дали редицата може да стане аритметична прогресия (същите елементи в друга наредба)



Задача 2.

Абстрактен клас
Player

С данни:
- name - низ с произволна дължина
- offensiveSkill, defensiveSkill - положителни числа

Производни Класовe
Attacker
- getSKill - връща (2*offensiveSkill + defensiveSkill)/3
- operator<< 

Defender
- getSKill - връща 3*defensiveSKill
- оператор<<

operator<< за производните класове трябва да изведе

"Name:" name

"Skill:" getSkill()


Клас  Team
Свързан списък от играчи

Допълнителни данни
int draws, wins, losses

функции:
- getTotalSkill(int n) - събира getSkill() на n-те най-добри играчи
- addPlayer - Няма значение къде в списъка ще се постави (бонус ако поставянето помага да се избегнат някои проверки (например за getTotalSkill))
- removePlayer - по-зададено име, маха поне един играч с това име.
- приятелска mergeTeams - нов отбор с n-те най-добри от 2 отбора
- приятелска game - сравнява totalSKill(n) на 2та отбора като n e броя играчи в по-малкия отбор, увеличава wins/draws/losses на 2та отбора в зависимост от резултата


Да се реализират канонично представяне, както и подходящи селектори и мутатори за всички класове. Без мутатори setWins, setDraws, setLosses (тези данни се променят само от функцията game)

Бонус:
За някаква реализация на свързан списък напишете функция, която проверява дали в списъка има цикъл. Има цикъл, ако в списъка участват 2 еднакви node-a. 2 node-a са еднакви, ако адресите им са еднакви (не само стойностите в тях)
Решението може да се предаде само като отделна функция в коментар или отделен текстов файл (не е нужна цяла реализация на списък) По-голям бонус, ако не се проверяват всички елементи.

